name: Build box64

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Box64 version (tag) to build (leave empty if using latest version)'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  build-matrix:
    name: Build Box64 using matrix
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [aarch64, rv64gc]
        dynarec: [true, false]

    outputs:
      build_info: ${{ steps.set_build_info.outputs.build_info }}
      version_ref: ${{ steps.set_ref.outputs.version_ref }}
      has_successful_builds: ${{ steps.check_builds.outputs.has_successful_builds }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Install dependencies
        run: |
          set -e
          echo "Installing dependencies for ${{ matrix.arch }}..."
          if [[ "${{ matrix.arch }}" == "aarch64" ]]; then
            sudo apt update || { echo "Failed to update apt packages"; exit 1; }
            sudo apt install -y build-essential cmake git gcc-aarch64-linux-gnu g++-aarch64-linux-gnu || { echo "Failed to install aarch64 dependencies"; exit 1; }
          elif [[ "${{ matrix.arch }}" == "rv64gc" ]]; then
            sudo apt update || { echo "Failed to update apt packages"; exit 1; }
            sudo apt install -y build-essential cmake git gcc-riscv64-linux-gnu g++-riscv64-linux-gnu || { echo "Failed to install RISC-V dependencies"; exit 1; }
          fi
          echo "Dependencies installed successfully"

      - name: Determine build version
        id: set_ref
        run: |
          set -e
          VERSION_INPUT="${{ github.event.inputs.version }}"
          if [[ -n "$VERSION_INPUT" ]]; then
            REF="$VERSION_INPUT"
            REF_TYPE="version"
            echo "Using provided version: $REF"
          else
            echo "Fetching latest tag from box64 repository..."
            latest_tag=$(git ls-remote --tags https://github.com/ptitSeb/box64 | awk -F/ '{print $3}' | grep -v '{}' | sort -V | tail -n1) || { echo "Failed to fetch latest tag"; exit 1; }
            if [[ -z "$latest_tag" ]]; then
              echo "ERROR: Could not determine latest tag"
              exit 1
            fi
            REF="$latest_tag"
            REF_TYPE="version"
            echo "Using latest tag: $REF"
          fi
          echo "ref=$REF" >> $GITHUB_ENV
          echo "reftype=$REF_TYPE" >> $GITHUB_ENV
          echo "version_ref=$REF" >> $GITHUB_OUTPUT

      - name: Clone box64 source
        run: |
          set -e
          echo "Cloning box64 repository..."
          git clone https://github.com/ptitSeb/box64.git src || { echo "Failed to clone box64 repository"; exit 1; }
          
          cd src
          echo "Checking out version: ${{ env.ref }}"
          
          if [[ "${{ env.reftype }}" == "version" ]]; then
            if git rev-parse "refs/tags/${{ env.ref }}" >/dev/null 2>&1; then
              git checkout "tags/${{ env.ref }}" || { echo "Failed to checkout tag ${{ env.ref }}"; exit 1; }
            else
              echo "ERROR: Tag '${{ env.ref }}' does not exist"
              exit 1
            fi
          else
            git checkout "${{ env.ref }}" || { echo "Failed to checkout commit ${{ env.ref }}"; exit 1; }
          fi
          echo "Successfully checked out ${{ env.ref }}"

      - name: Check version support
        id: check_support
        run: |
          set -e
          echo "Checking version support for ${{ env.ref }}..."
          
          # Extract version number safely
          if [[ ! "${{ env.ref }}" =~ ^v?[0-9] ]]; then
            echo "ERROR: Invalid version format: ${{ env.ref }}"
            exit 1
          fi
          
          ver=$(echo "${{ env.ref }}" | sed 's/^v//')
          major=$(echo "$ver" | awk -F. '{print $1}')
          minor=$(echo "$ver" | awk -F. '{print $2}')
          patch=$(echo "$ver" | awk -F. '{print $3}')
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}
          ver_num=$(( major * 10000 + minor * 100 + patch ))
          
          echo "Version components: major=$major, minor=$minor, patch=$patch, numeric=$ver_num"
          
          skip_build=false
          skip_dynarec=false
          
          # RISC-V support from v0.1.8
          if [[ "${{ matrix.arch }}" == "rv64gc" && $ver_num -lt 108 ]]; then
            echo "WARNING: RISC-V not supported in version ${{ env.ref }} (needs v0.1.8+)"
            skip_build=true
          fi
          
          # Dynarec support checks
          if [[ "${{ matrix.dynarec }}" == "true" ]]; then
            if [[ "${{ matrix.arch }}" == "aarch64" && $ver_num -lt 6 ]]; then
              echo "WARNING: ARM64 dynarec not supported in version ${{ env.ref }} (needs v0.0.6+)"
              skip_dynarec=true
            elif [[ "${{ matrix.arch }}" == "rv64gc" && $ver_num -lt 204 ]]; then
              echo "WARNING: RISC-V dynarec not supported in version ${{ env.ref }} (needs v0.2.4+)"
              skip_dynarec=true
            fi
          fi
          
          echo "skip_build=$skip_build" >> $GITHUB_OUTPUT
          echo "skip_dynarec=$skip_dynarec" >> $GITHUB_OUTPUT

      - name: Build box64
        if: steps.check_support.outputs.skip_build != 'true' && steps.check_support.outputs.skip_dynarec != 'true'
        run: |
          set -e
          echo "Starting build for ${{ matrix.arch }} (dynarec: ${{ matrix.dynarec }})..."
          
          WORKDIR=$GITHUB_WORKSPACE
          SOURCE_DIR=$WORKDIR/src
          BUILD_DIR=$WORKDIR/build-${{ matrix.arch }}-${{ matrix.dynarec }}
          
          # Verify source directory exists
          if [[ ! -d "$SOURCE_DIR" ]]; then
            echo "ERROR: Source directory $SOURCE_DIR does not exist"
            exit 1
          fi
          
          mkdir -p $BUILD_DIR || { echo "Failed to create build directory"; exit 1; }
          cd $BUILD_DIR
          
          # Set up compiler based on architecture
          if [[ "${{ matrix.arch }}" == "aarch64" ]]; then
            SYSTEM_PROCESSOR="aarch64"
            C_COMPILER="aarch64-linux-gnu-gcc"
            # ARM64 specific flags
            if [[ "${{ matrix.dynarec }}" == "true" ]]; then
              FLAGS="-DARM_DYNAREC=ON"
              DYNAREC_SUFFIX="-dynarec"
              echo "ARM64 Dynarec: ENABLED"
            else
              FLAGS=""
              DYNAREC_SUFFIX=""
              echo "ARM64 Dynarec: DISABLED"
            fi
          elif [[ "${{ matrix.arch }}" == "rv64gc" ]]; then
            SYSTEM_PROCESSOR="riscv64"
            C_COMPILER="riscv64-linux-gnu-gcc"
            # RISC-V specific flags
            if [[ "${{ matrix.dynarec }}" == "true" ]]; then
              FLAGS="-DRV64_DYNAREC=ON"
              DYNAREC_SUFFIX="-dynarec"
              echo "RISC-V Dynarec: ENABLED"
            else
              FLAGS=""
              DYNAREC_SUFFIX=""
              echo "RISC-V Dynarec: DISABLED"
            fi
          fi
          
          # Verify compiler is available
          if ! command -v "$C_COMPILER" &> /dev/null; then
            echo "ERROR: Compiler $C_COMPILER not found"
            exit 1
          fi
          
          # Base build configuration - ONLY C compiler, no C++
          FLAGS="$FLAGS -DCMAKE_BUILD_TYPE=Release"
          FLAGS="$FLAGS -DCMAKE_SYSTEM_NAME=Linux"
          FLAGS="$FLAGS -DCMAKE_SYSTEM_PROCESSOR=$SYSTEM_PROCESSOR"
          FLAGS="$FLAGS -DCMAKE_C_COMPILER=$C_COMPILER"
          
          # BOX32 support (from v0.3.2)
          ver=$(echo "${{ env.ref }}" | sed 's/^v//')
          major=$(echo "$ver" | awk -F. '{print $1}')
          minor=$(echo "$ver" | awk -F. '{print $2}')
          patch=$(echo "$ver" | awk -F. '{print $3}')
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}
          ver_num=$(( major * 10000 + minor * 100 + patch ))
          
          if [[ $ver_num -ge 302 ]]; then  # v0.3.2+
            FLAGS="$FLAGS -DBOX32=ON -DBOX32_BINFMT=ON"
            BOX32_SUFFIX="-box32"
            echo "Box32: ENABLED"
          else
            FLAGS="$FLAGS -DBOX32=OFF"
            BOX32_SUFFIX=""
            echo "Box32: DISABLED (requires v0.3.2+)"
          fi
          
          # Store suffixes in environment for later steps
          echo "DYNAREC_SUFFIX=$DYNAREC_SUFFIX" >> $GITHUB_ENV
          echo "BOX32_SUFFIX=$BOX32_SUFFIX" >> $GITHUB_ENV
          
          echo "Running cmake with flags: $FLAGS"
          cmake $SOURCE_DIR $FLAGS || { echo "CMake configuration failed"; exit 1; }
          
          echo "Running make..."
          make -j$(nproc) || { echo "make failed"; exit 1; }
          
          # Find and copy binary
          echo "Locating built binary..."
          BINARY_PATH=$(find $BUILD_DIR -type f -name "box64" -executable | head -n1)
          if [[ -f "$BINARY_PATH" ]]; then
            mkdir -p $WORKDIR/artifacts || { echo "Failed to create artifacts directory"; exit 1; }
            ARTIFACT_NAME="box64-${{ env.ref }}-${{ matrix.arch }}${DYNAREC_SUFFIX}${BOX32_SUFFIX}"
            cp "$BINARY_PATH" "$WORKDIR/artifacts/$ARTIFACT_NAME" || { echo "Failed to copy binary"; exit 1; }
            echo "Build successful: $ARTIFACT_NAME"
            
            # Store artifact name for upload step
            echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          else
            echo "ERROR: box64 binary not found in $BUILD_DIR"
            echo "Build directory contents:"
            find $BUILD_DIR -type f | head -20
            exit 1
          fi

      - name: Upload to GitHub Actions Artifacts
        if: steps.check_support.outputs.skip_build != 'true' && steps.check_support.outputs.skip_dynarec != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: artifacts/${{ env.ARTIFACT_NAME }}

      - name: Set build info for release
        if: steps.check_support.outputs.skip_build != 'true' && steps.check_support.outputs.skip_dynarec != 'true'
        id: set_build_info
        run: |
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          # Create JSON build info for this specific build
          BUILD_INFO=$(jq -n \
            --arg arch "${{ matrix.arch }}" \
            --arg dynarec "${{ matrix.dynarec }}" \
            --arg box32 "${{ env.BOX32_SUFFIX != '' }}" \
            --arg artifact "${{ env.ARTIFACT_NAME }}" \
            --arg date "$BUILD_DATE" \
            '{
              arch: $arch,
              dynarec: $dynarec,
              box32: $box32,
              artifact: $artifact,
              date: $date
            }')
          
          echo "build_info=$BUILD_INFO" >> $GITHUB_OUTPUT

      - name: Check if any builds were successful
        if: always()
        id: check_builds
        run: |
          # Check if this specific matrix job built successfully
          if [[ "${{ steps.check_support.outputs.skip_build }}" != "true" && "${{ steps.check_support.outputs.skip_dynarec }}" != "true" && "${{ job.status }}" == "success" ]]; then
            echo "This matrix job built successfully"
            echo "has_successful_builds=true" >> $GITHUB_OUTPUT
          else
            echo "This matrix job did not produce a build"
            echo "has_successful_builds=false" >> $GITHUB_OUTPUT
          fi

  # Create release after all builds complete
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build-matrix
    # Only create release if ALL matrix jobs completed AND at least one build was successful
    if: needs.build-matrix.result == 'success' && needs.build-matrix.outputs.has_successful_builds == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Check if any artifacts exist
        id: check_artifacts
        run: |
          if find release-artifacts -name "box64-*" -type f | read; then
            echo "Artifacts found, proceeding with release creation"
            echo "artifacts_exist=true" >> $GITHUB_OUTPUT
          else
            echo "No artifacts found, skipping release creation"
            echo "artifacts_exist=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate release body
        id: generate_release_body
        run: |
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          VERSION_REF="${{ needs.build-matrix.outputs.version_ref || github.event.inputs.version || 'latest' }}"
          
          # Start building the release body
          RELEASE_BODY="# Box64 $VERSION_REF - Automated Builds"
          RELEASE_BODY="$RELEASE_BODY\n\n"
          RELEASE_BODY="$RELEASE_BODYAutomated builds of [Box64 $VERSION_REF](https://github.com/ptitSeb/box64/releases/latest)\n\n"
          
          RELEASE_BODY="$RELEASE_BODY## Available Builds\n\n"
          RELEASE_BODY="$RELEASE_BODY| Architecture | Dynarec | Box32 | Filename |\n"
          RELEASE_BODY="$RELEASE_BODY|--------------|---------|-------|----------|\n"
          
          # Collect only successful builds by scanning actual artifacts
          SUCCESSFUL_BUILDS=()
          
          echo "Scanning for built artifacts..."
          while IFS= read -r -d '' file; do
            ARTIFACT_NAME=$(basename "$file")
            echo "Found artifact: $ARTIFACT_NAME"
            
            # Parse info from filename: box64-{version}-{arch}{-dynarec}{-box32}
            if [[ "$ARTIFACT_NAME" =~ box64-(.+)-(.+)$ ]]; then
              VERSION_PART="${BASH_REMATCH[1]}"
              ARCH_PART="${BASH_REMATCH[2]}"
              
              # Detect architecture
              if [[ "$ARCH_PART" == *"aarch64"* ]]; then
                ARCH="aarch64"
              elif [[ "$ARCH_PART" == *"rv64gc"* ]]; then
                ARCH="rv64gc"
              else
                ARCH="unknown"
              fi
              
              # Detect features from filename
              if [[ "$ARCH_PART" == *"dynarec"* ]]; then
                DYNAREC_DISPLAY="yes"
              else
                DYNAREC_DISPLAY="no"
              fi
              
              if [[ "$ARCH_PART" == *"box32"* ]]; then
                BOX32_DISPLAY="yes"
              else
                BOX32_DISPLAY="no"
              fi
              
              RELEASE_BODY="$RELEASE_BODY| $ARCH | $DYNAREC_DISPLAY | $BOX32_DISPLAY | \`$ARTIFACT_NAME\` |\n"
              SUCCESSFUL_BUILDS+=("$ARTIFACT_NAME")
            fi
          done < <(find release-artifacts -type f -name "box64-*" -print0)
          
          # If no successful builds were found, skip release
          if [[ ${#SUCCESSFUL_BUILDS[@]} -eq 0 ]]; then
            echo "No successful builds found, cannot create release"
            exit 1
          fi
          
          RELEASE_BODY="$RELEASE_BODY\n## Usage\n"
          RELEASE_BODY="$RELEASE_BODY\`\`\`bash\n"
          RELEASE_BODY="$RELEASE_BODYchmod +x box64-*\n"
          RELEASE_BODY="$RELEASE_BODY./box64-* your_x86_application\n"
          RELEASE_BODY="$RELEASE_BODY\`\`\`\n\n"
          
          RELEASE_BODY="$RELEASE_BODY## Build Information\n"
          RELEASE_BODY="$RELEASE_BODY- **Build Date**: $BUILD_DATE\n"
          RELEASE_BODY="$RELEASE_BODY- **Workflow**: [#${{ github.run_number }}]($GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)\n"
          RELEASE_BODY="$RELEASE_BODY- **Source**: [Box64 $VERSION_REF](https://github.com/ptitSeb/box64/releases/latest)\n"
          
          # Store the release body
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.check_artifacts.outputs.artifacts_exist == 'true'
        uses: softprops/action-gh-release@v1
        with:
          files: release-artifacts/**/*
          tag_name: box64-${{ needs.build-matrix.outputs.version_ref || github.event.inputs.version || 'latest' }}
          name: "Box64 ${{ needs.build-matrix.outputs.version_ref || github.event.inputs.version || 'latest' }}"
          body: ${{ steps.generate_release_body.outputs.release_body }}
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}